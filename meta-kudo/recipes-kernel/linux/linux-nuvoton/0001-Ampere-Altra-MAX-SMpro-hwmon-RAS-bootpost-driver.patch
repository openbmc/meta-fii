From 0b617951e5ea6433dfdb3c7d006dfac9713401c7 Mon Sep 17 00:00:00 2001
From: Lancelot Kao <lancelot.kao@fii-usa.com>
Date: Mon, 19 Oct 2020 18:28:32 -0500
Subject: [PATCH] Ampere Altra (MAX) SMpro hwmon/RAS/bootpost driver

1. This commit refactors smpro-hwmon.c driver based on the MFD
framework and to handle only hwmon-related SMpro sensors
including temperature, voltage, power, current, etc.
2. Ampere SMpro Misc driver provides support for monitoring various
SMPro's data other than hwmon data.
3. Ampere SMpro Misc driver provides support for monitoring various
SMPro's data other than hwmon data.
4. There are I2C devices which contain several different functions but
doesn't require any special access functions. For these kind of drivers
an I2C regmap should be enough.

Create an I2C driver which creates an I2C regmap and enumerates its
children. If a device wants to use this as its MFD core driver, it has
to add an individual compatible string. It may provide its own regmap
configuration.

Subdevices can use dev_get_regmap() on the parent to get their regmap
instance.

Backport from
https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/commit?h=next-20201123&id=3abee4579484c554961bb0af92a77adc0ebd791d

Signed-off-by: Michael Walle <michael@walle.cc>
Signed-off-by: Lee Jones <lee.jones@linaro.org>
Signed-off-by: Quan Nguyen <qnguyen@amperecomputing.com>
---
 MAINTAINERS                  |   7 +
 drivers/base/regmap/regmap.c |  72 ++--
 drivers/hwmon/Kconfig        |   7 +
 drivers/hwmon/Makefile       |   1 +
 drivers/hwmon/smpro-hwmon.c  | 631 +++++++++++++++++++++++++++++++++++
 drivers/mfd/Kconfig          |  32 ++
 drivers/mfd/Makefile         |   2 +-
 drivers/mfd/simple-mfd-i2c.c |  68 ++++
 drivers/misc/Kconfig         |  14 +
 drivers/misc/Makefile        |   2 +
 drivers/misc/smpro-errmon.c  | 587 ++++++++++++++++++++++++++++++++
 drivers/misc/smpro-misc.c    | 249 ++++++++++++++
 include/linux/regmap.h       |   2 +
 13 files changed, 1643 insertions(+), 31 deletions(-)
 create mode 100644 drivers/hwmon/smpro-hwmon.c
 create mode 100644 drivers/mfd/simple-mfd-i2c.c
 create mode 100644 drivers/misc/smpro-errmon.c
 create mode 100644 drivers/misc/smpro-misc.c

diff --git a/MAINTAINERS b/MAINTAINERS
index 5fecb388d073..2ec3fe5530f7 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -934,6 +934,13 @@ S:	Supported
 F:	arch/arm64/boot/dts/amd/amd-seattle-xgbe*.dtsi
 F:	drivers/net/ethernet/amd/xgbe/
 
+AMPERE COMPUTING SMpro DRIVER
+M:	Thu Ba Nguyen <tbnguyen@os.amperecomputing.com>
+S:	Supported
+F:	Documentation/devicetree/bindings/i2c/ampere,smpro.yaml
+F:	arch/arm/boot/dts/aspeed-bmc-ampere-mtjade.dts
+F:	drivers/hwmon/smpro-hwmon.c
+
 ANALOG DEVICES INC AD5686 DRIVER
 M:	Michael Hennerich <Michael.Hennerich@analog.com>
 L:	linux-pm@vger.kernel.org
diff --git a/drivers/base/regmap/regmap.c b/drivers/base/regmap/regmap.c
index 9751304c5c15..f36d152393d2 100644
--- a/drivers/base/regmap/regmap.c
+++ b/drivers/base/regmap/regmap.c
@@ -87,6 +87,18 @@ bool regmap_check_range_table(struct regmap *map, unsigned int reg,
 }
 EXPORT_SYMBOL_GPL(regmap_check_range_table);
 
+void regmap_acquire_lock(struct regmap *map)
+{
+	map->lock(map->lock_arg);
+}
+EXPORT_SYMBOL_GPL(regmap_acquire_lock);
+
+void regmap_release_lock(struct regmap *map)
+{
+	map->unlock(map->lock_arg);
+}
+EXPORT_SYMBOL_GPL(regmap_release_lock);
+
 bool regmap_writeable(struct regmap *map, unsigned int reg)
 {
 	if (map->max_register && reg > map->max_register)
@@ -115,9 +127,9 @@ bool regmap_cached(struct regmap *map, unsigned int reg)
 	if (map->max_register && reg > map->max_register)
 		return false;
 
-	map->lock(map->lock_arg);
+	regmap_acquire_lock(map);
 	ret = regcache_read(map, reg, &val);
-	map->unlock(map->lock_arg);
+	regmap_release_lock(map);
 	if (ret)
 		return false;
 
@@ -1803,11 +1815,11 @@ int regmap_write(struct regmap *map, unsigned int reg, unsigned int val)
 	if (!IS_ALIGNED(reg, map->reg_stride))
 		return -EINVAL;
 
-	map->lock(map->lock_arg);
+	regmap_acquire_lock(map);
 
 	ret = _regmap_write(map, reg, val);
 
-	map->unlock(map->lock_arg);
+	regmap_release_lock(map);
 
 	return ret;
 }
@@ -1830,7 +1842,7 @@ int regmap_write_async(struct regmap *map, unsigned int reg, unsigned int val)
 	if (!IS_ALIGNED(reg, map->reg_stride))
 		return -EINVAL;
 
-	map->lock(map->lock_arg);
+	regmap_acquire_lock(map);
 
 	map->async = true;
 
@@ -1838,7 +1850,7 @@ int regmap_write_async(struct regmap *map, unsigned int reg, unsigned int val)
 
 	map->async = false;
 
-	map->unlock(map->lock_arg);
+	regmap_release_lock(map);
 
 	return ret;
 }
@@ -1908,11 +1920,11 @@ int regmap_raw_write(struct regmap *map, unsigned int reg,
 	if (val_len % map->format.val_bytes)
 		return -EINVAL;
 
-	map->lock(map->lock_arg);
+	regmap_acquire_lock(map);
 
 	ret = _regmap_raw_write(map, reg, val, val_len, false);
 
-	map->unlock(map->lock_arg);
+	regmap_release_lock(map);
 
 	return ret;
 }
@@ -1956,7 +1968,7 @@ int regmap_noinc_write(struct regmap *map, unsigned int reg,
 	if (val_len == 0)
 		return -EINVAL;
 
-	map->lock(map->lock_arg);
+	regmap_acquire_lock(map);
 
 	if (!regmap_volatile(map, reg) || !regmap_writeable_noinc(map, reg)) {
 		ret = -EINVAL;
@@ -1976,7 +1988,7 @@ int regmap_noinc_write(struct regmap *map, unsigned int reg,
 	}
 
 out_unlock:
-	map->unlock(map->lock_arg);
+	regmap_release_lock(map);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(regmap_noinc_write);
@@ -2069,7 +2081,7 @@ int regmap_bulk_write(struct regmap *map, unsigned int reg, const void *val,
 	 * single write operations.
 	 */
 	if (!map->bus || !map->format.parse_inplace) {
-		map->lock(map->lock_arg);
+		regmap_acquire_lock(map);
 		for (i = 0; i < val_count; i++) {
 			unsigned int ival;
 
@@ -2100,7 +2112,7 @@ int regmap_bulk_write(struct regmap *map, unsigned int reg, const void *val,
 				goto out;
 		}
 out:
-		map->unlock(map->lock_arg);
+		regmap_release_lock(map);
 	} else {
 		void *wval;
 
@@ -2359,11 +2371,11 @@ int regmap_multi_reg_write(struct regmap *map, const struct reg_sequence *regs,
 {
 	int ret;
 
-	map->lock(map->lock_arg);
+	regmap_acquire_lock(map);
 
 	ret = _regmap_multi_reg_write(map, regs, num_regs);
 
-	map->unlock(map->lock_arg);
+	regmap_release_lock(map);
 
 	return ret;
 }
@@ -2394,7 +2406,7 @@ int regmap_multi_reg_write_bypassed(struct regmap *map,
 	int ret;
 	bool bypass;
 
-	map->lock(map->lock_arg);
+	regmap_acquire_lock(map);
 
 	bypass = map->cache_bypass;
 	map->cache_bypass = true;
@@ -2403,7 +2415,7 @@ int regmap_multi_reg_write_bypassed(struct regmap *map,
 
 	map->cache_bypass = bypass;
 
-	map->unlock(map->lock_arg);
+	regmap_release_lock(map);
 
 	return ret;
 }
@@ -2441,7 +2453,7 @@ int regmap_raw_write_async(struct regmap *map, unsigned int reg,
 	if (!IS_ALIGNED(reg, map->reg_stride))
 		return -EINVAL;
 
-	map->lock(map->lock_arg);
+	regmap_acquire_lock(map);
 
 	map->async = true;
 
@@ -2449,7 +2461,7 @@ int regmap_raw_write_async(struct regmap *map, unsigned int reg,
 
 	map->async = false;
 
-	map->unlock(map->lock_arg);
+	regmap_release_lock(map);
 
 	return ret;
 }
@@ -2563,11 +2575,11 @@ int regmap_read(struct regmap *map, unsigned int reg, unsigned int *val)
 	if (!IS_ALIGNED(reg, map->reg_stride))
 		return -EINVAL;
 
-	map->lock(map->lock_arg);
+	regmap_acquire_lock(map);
 
 	ret = _regmap_read(map, reg, val);
 
-	map->unlock(map->lock_arg);
+	regmap_release_lock(map);
 
 	return ret;
 }
@@ -2601,7 +2613,7 @@ int regmap_raw_read(struct regmap *map, unsigned int reg, void *val,
 	if (val_count == 0)
 		return -EINVAL;
 
-	map->lock(map->lock_arg);
+	regmap_acquire_lock(map);
 
 	if (regmap_volatile_range(map, reg, val_count) || map->cache_bypass ||
 	    map->cache_type == REGCACHE_NONE) {
@@ -2653,7 +2665,7 @@ int regmap_raw_read(struct regmap *map, unsigned int reg, void *val,
 	}
 
  out:
-	map->unlock(map->lock_arg);
+	regmap_release_lock(map);
 
 	return ret;
 }
@@ -2697,7 +2709,7 @@ int regmap_noinc_read(struct regmap *map, unsigned int reg,
 	if (val_len == 0)
 		return -EINVAL;
 
-	map->lock(map->lock_arg);
+	regmap_acquire_lock(map);
 
 	if (!regmap_volatile(map, reg) || !regmap_readable_noinc(map, reg)) {
 		ret = -EINVAL;
@@ -2717,7 +2729,7 @@ int regmap_noinc_read(struct regmap *map, unsigned int reg,
 	}
 
 out_unlock:
-	map->unlock(map->lock_arg);
+	regmap_release_lock(map);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(regmap_noinc_read);
@@ -2818,7 +2830,7 @@ int regmap_bulk_read(struct regmap *map, unsigned int reg, void *val,
 		u16 *u16 = val;
 		u8 *u8 = val;
 
-		map->lock(map->lock_arg);
+		regmap_acquire_lock(map);
 
 		for (i = 0; i < val_count; i++) {
 			unsigned int ival;
@@ -2850,7 +2862,7 @@ int regmap_bulk_read(struct regmap *map, unsigned int reg, void *val,
 		}
 
 out:
-		map->unlock(map->lock_arg);
+		regmap_release_lock(map);
 	}
 
 	return ret;
@@ -2917,7 +2929,7 @@ int regmap_update_bits_base(struct regmap *map, unsigned int reg,
 {
 	int ret;
 
-	map->lock(map->lock_arg);
+	regmap_acquire_lock(map);
 
 	map->async = async;
 
@@ -2925,7 +2937,7 @@ int regmap_update_bits_base(struct regmap *map, unsigned int reg,
 
 	map->async = false;
 
-	map->unlock(map->lock_arg);
+	regmap_release_lock(map);
 
 	return ret;
 }
@@ -3058,7 +3070,7 @@ int regmap_register_patch(struct regmap *map, const struct reg_sequence *regs,
 		return -ENOMEM;
 	}
 
-	map->lock(map->lock_arg);
+	regmap_acquire_lock(map);
 
 	bypass = map->cache_bypass;
 
@@ -3070,7 +3082,7 @@ int regmap_register_patch(struct regmap *map, const struct reg_sequence *regs,
 	map->async = false;
 	map->cache_bypass = bypass;
 
-	map->unlock(map->lock_arg);
+	regmap_release_lock(map);
 
 	regmap_async_complete(map);
 
diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
index 9aa89d7d4193..b96a89f8133a 100644
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -1599,6 +1599,13 @@ config SENSORS_EMC6W201
 	  This driver can also be built as a module. If so, the module
 	  will be called emc6w201.
 
+config SENSORS_SMPRO
+	tristate "Ampere Computing SMpro hardware monitoring driver"
+	depends on MFD_SMPRO || COMPILE_TEST
+	help
+	  If you say yes here you get support for the thermal, voltage, current
+	  and power sensors of Ampere Computing's SoC with SMpro processor.
+
 config SENSORS_SMSC47M1
 	tristate "SMSC LPC47M10x and compatibles"
 	depends on !PPC
diff --git a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
index ae41ee71a71b..987fb95880f5 100644
--- a/drivers/hwmon/Makefile
+++ b/drivers/hwmon/Makefile
@@ -166,6 +166,7 @@ obj-$(CONFIG_SENSORS_SHT3x)	+= sht3x.o
 obj-$(CONFIG_SENSORS_SHTC1)	+= shtc1.o
 obj-$(CONFIG_SENSORS_SIS5595)	+= sis5595.o
 obj-$(CONFIG_SENSORS_SMM665)	+= smm665.o
+obj-$(CONFIG_SENSORS_SMPRO)	+= smpro-hwmon.o
 obj-$(CONFIG_SENSORS_SMSC47B397)+= smsc47b397.o
 obj-$(CONFIG_SENSORS_SMSC47M1)	+= smsc47m1.o
 obj-$(CONFIG_SENSORS_SMSC47M192)+= smsc47m192.o
diff --git a/drivers/hwmon/smpro-hwmon.c b/drivers/hwmon/smpro-hwmon.c
new file mode 100644
index 000000000000..715fd9e0f169
--- /dev/null
+++ b/drivers/hwmon/smpro-hwmon.c
@@ -0,0 +1,631 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Ampere Computing SoC's SMpro Hardware Monitoring Driver
+ *
+ * Copyright (c) 2019-2020, Ampere Computing LLC
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/bitfield.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/kernel.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/property.h>
+#include <linux/regmap.h>
+
+/* Identification Registers */
+#define MANUFACTURER_ID_REG             0x02
+#define AMPERE_MANUFACTURER_ID		0xCD3A
+
+/* Capability Registers  */
+#define SOC_TDP_REG                     0x0E
+
+/* Logical Power Sensor Registers */
+#define SOC_TEMP_REG                    0x10
+#define SOC_VRD_TEMP_REG                0x11
+#define DIMM_VRD_TEMP_REG               0x12
+#define CORE_VRD_TEMP_REG               0x13
+#define CH0_DIMM_TEMP_REG               0x14
+#define CH1_DIMM_TEMP_REG               0x15
+#define CH2_DIMM_TEMP_REG               0x16
+#define CH3_DIMM_TEMP_REG               0x17
+#define CH4_DIMM_TEMP_REG               0x18
+#define CH5_DIMM_TEMP_REG               0x19
+#define CH6_DIMM_TEMP_REG               0x1A
+#define CH7_DIMM_TEMP_REG               0x1B
+#define RCA_VRD_TEMP_REG                0x1C
+
+#define CORE_VRD_PWR_REG                0x20
+#define SOC_VRD_PWR_REG                 0x21
+#define DIMM_VRD1_PWR_REG               0x22
+#define DIMM_VRD2_PWR_REG               0x23
+#define CORE_VRD_PWR_MW_REG             0x26
+#define SOC_VRD_PWR_MW_REG              0x27
+#define DIMM_VRD1_PWR_MW_REG            0x28
+#define DIMM_VRD2_PWR_MW_REG            0x29
+#define RCA_VRD_PWR_REG                 0x2A
+#define RCA_VRD_PWR_MW_REG              0x2B
+
+#define MEM_HOT_THRESHOLD_REG           0x32
+#define SOC_VR_HOT_THRESHOLD_REG        0x33
+#define CORE_VRD_VOLT_REG               0x34
+#define SOC_VRD_VOLT_REG                0x35
+#define DIMM_VRD1_VOLT_REG              0x36
+#define DIMM_VRD2_VOLT_REG              0x37
+#define RCA_VRD_VOLT_REG                0x38
+
+#define CORE_VRD_CURR_REG               0x39
+#define SOC_VRD_CURR_REG                0x3A
+#define DIMM_VRD1_CURR_REG              0x3B
+#define DIMM_VRD2_CURR_REG              0x3C
+#define RCA_VRD_CURR_REG                0x3D
+
+/* Add for DIMM group */
+#define DIMM_GROUP_DUMMY_REG            0xFF
+
+struct smpro_hwmon {
+	struct regmap *regmap;
+};
+
+static const u8 temp_regs[] = {
+	SOC_TEMP_REG,
+	SOC_VRD_TEMP_REG,
+	DIMM_VRD_TEMP_REG,
+	CORE_VRD_TEMP_REG,
+	/* reserved for DIMM G0 */
+	DIMM_GROUP_DUMMY_REG,
+	CH0_DIMM_TEMP_REG,
+	CH1_DIMM_TEMP_REG,
+	CH2_DIMM_TEMP_REG,
+	CH3_DIMM_TEMP_REG,
+	/* reserved for DIMM G1 */
+	DIMM_GROUP_DUMMY_REG,
+	CH4_DIMM_TEMP_REG,
+	CH5_DIMM_TEMP_REG,
+	CH6_DIMM_TEMP_REG,
+	CH7_DIMM_TEMP_REG,
+	MEM_HOT_THRESHOLD_REG,
+	SOC_VR_HOT_THRESHOLD_REG,
+	RCA_VRD_TEMP_REG,
+};
+
+static const u8 volt_regs[] = {
+	CORE_VRD_VOLT_REG,
+	SOC_VRD_VOLT_REG,
+	DIMM_VRD1_VOLT_REG,
+	DIMM_VRD2_VOLT_REG,
+	/* vrd1 has higher priority than vrd2 using vrd1 as output for ddr */
+	DIMM_VRD1_VOLT_REG,
+	RCA_VRD_VOLT_REG,
+};
+
+static const u8 curr_regs[] = {
+	CORE_VRD_CURR_REG,
+	SOC_VRD_CURR_REG,
+	DIMM_VRD1_CURR_REG,
+	DIMM_VRD2_CURR_REG,
+	RCA_VRD_CURR_REG,
+};
+
+enum pwr_regs {
+	PMD_VRD_PWR,
+	SOC_VRD_PWR,
+	DIMM_VRD1_PWR,
+	DIMM_VRD2_PWR,
+	CPU_VRD_PWR,
+	DIMM_VRD_PWR,
+	RCA_VRD_PWR,
+	SOC_TDP_PWR,
+};
+static const char * const label[] = {
+	"SoC",
+	"SoC VRD",
+	"DIMM VRD",
+	"DIMM VRD1",
+	"DIMM VRD2",
+	"PMD VRD",
+	"CH0 DIMM",
+	"CH1 DIMM",
+	"CH2 DIMM",
+	"CH3 DIMM",
+	"CH4 DIMM",
+	"CH5 DIMM",
+	"CH6 DIMM",
+	"CH7 DIMM",
+	"MEM HOT",
+	"SoC VR HOT",
+	"CPU VRD",
+	"RCA VRD",
+	"SOC TDP",
+	"DIMM G0",
+	"DIMM G1",
+};
+
+static int smpro_read_temp(struct device *dev, u32 attr, int channel,
+				long *val)
+{
+	struct smpro_hwmon *hwmon = dev_get_drvdata(dev);
+	unsigned int t_max = 0xFFFFFFFF;
+	unsigned int value;
+	s32 i = 0;
+	int ret = -1;
+
+	switch (attr) {
+	case hwmon_temp_input:
+		if (temp_regs[channel] == DIMM_GROUP_DUMMY_REG) {
+			for (i = 1; i <= 4; i++) {
+				ret = regmap_read(hwmon->regmap,
+						temp_regs[channel + i], &value);
+				if (ret)
+					return ret;
+
+				if (value == 0xFFFF)
+					continue;
+
+				value &= 0x1ff;
+				if (t_max != 0xFFFFFFFF)
+					t_max = (value > t_max) ? value : t_max;
+				else
+					t_max = value;
+			}
+			if (t_max == 0xFFFFFFFF)
+				return -1;
+			*val = (t_max & 0x1ff) * 1000;
+		} else {
+			ret = regmap_read(hwmon->regmap,
+					temp_regs[channel], &value);
+			if (ret)
+				return ret;
+			*val = (value & 0x1ff) * 1000;
+		}
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
+}
+
+static int smpro_read_in(struct device *dev, u32 attr, int channel,
+				long *val)
+{
+	struct smpro_hwmon *hwmon = dev_get_drvdata(dev);
+	unsigned int value;
+	int ret;
+
+	switch (attr) {
+	case hwmon_in_input:
+		ret = regmap_read(hwmon->regmap, volt_regs[channel], &value);
+		if (ret < 0)
+			return ret;
+		*val = value & 0x7fff;
+		return 0;
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+static int smpro_read_curr(struct device *dev, u32 attr, int channel,
+				long *val)
+{
+	struct smpro_hwmon *hwmon = dev_get_drvdata(dev);
+	unsigned int value;
+	int ret;
+
+	switch (attr) {
+	case hwmon_curr_input:
+		ret = regmap_read(hwmon->regmap, curr_regs[channel], &value);
+		if (ret < 0)
+			return ret;
+		*val = value & 0x7fff;
+		return 0;
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+static int smpro_read_power(struct device *dev, u32 attr, int channel,
+				long *val_pwr)
+{
+	struct smpro_hwmon *hwmon = dev_get_drvdata(dev);
+	unsigned int val2 = 0, val2_mw = 0;
+	unsigned int val = 0, val_mw = 0;
+	int ret = 0;
+
+	switch (attr) {
+	case hwmon_power_input:
+		switch (channel) {
+		case PMD_VRD_PWR:
+			if (!ret)
+				ret = regmap_read(hwmon->regmap,
+						CORE_VRD_PWR_REG, &val);
+			if (!ret)
+				ret = regmap_read(hwmon->regmap,
+						CORE_VRD_PWR_MW_REG, &val_mw);
+			if (ret)
+				return ret;
+			break;
+		case SOC_VRD_PWR:
+			if (!ret)
+				ret = regmap_read(hwmon->regmap,
+						SOC_VRD_PWR_REG, &val);
+			if (!ret)
+				ret = regmap_read(hwmon->regmap,
+						SOC_VRD_PWR_MW_REG, &val_mw);
+			if (ret)
+				return ret;
+			break;
+		case DIMM_VRD1_PWR:
+			if (!ret)
+				ret = regmap_read(hwmon->regmap,
+						DIMM_VRD1_PWR_REG, &val);
+			if (!ret)
+				ret = regmap_read(hwmon->regmap,
+						DIMM_VRD1_PWR_MW_REG, &val_mw);
+			if (ret)
+				return ret;
+			break;
+		case DIMM_VRD2_PWR:
+			if (!ret)
+				ret = regmap_read(hwmon->regmap,
+						DIMM_VRD2_PWR_REG, &val);
+			if (!ret)
+				ret = regmap_read(hwmon->regmap,
+						DIMM_VRD2_PWR_MW_REG, &val_mw);
+			if (ret)
+				return ret;
+			break;
+		case RCA_VRD_PWR:
+			if (!ret)
+				ret = regmap_read(hwmon->regmap,
+						RCA_VRD_PWR_REG, &val);
+			if (!ret)
+				ret = regmap_read(hwmon->regmap,
+						RCA_VRD_PWR_MW_REG, &val_mw);
+			if (ret)
+				return ret;
+			break;
+		case SOC_TDP_PWR:
+			if (!ret)
+				ret = regmap_read(hwmon->regmap,
+						SOC_TDP_REG, &val);
+			if (ret)
+				return ret;
+			break;
+		case CPU_VRD_PWR:
+			if (!ret)
+				ret = regmap_read(hwmon->regmap,
+						CORE_VRD_PWR_REG, &val);
+			if (!ret)
+				ret = regmap_read(hwmon->regmap,
+						CORE_VRD_PWR_MW_REG, &val_mw);
+			if (!ret)
+				ret = regmap_read(hwmon->regmap,
+						SOC_VRD_PWR_REG, &val2);
+			if (!ret)
+				ret = regmap_read(hwmon->regmap,
+						SOC_VRD_PWR_MW_REG, &val2_mw);
+			if (ret)
+				return ret;
+			break;
+		case DIMM_VRD_PWR:
+			if (!ret)
+				ret = regmap_read(hwmon->regmap,
+						DIMM_VRD1_PWR_REG, &val);
+			if (!ret)
+				ret = regmap_read(hwmon->regmap,
+						DIMM_VRD1_PWR_MW_REG, &val_mw);
+			if (!ret)
+				ret = regmap_read(hwmon->regmap,
+						DIMM_VRD2_PWR_REG, &val2);
+			if (!ret)
+				ret = regmap_read(hwmon->regmap,
+						DIMM_VRD2_PWR_MW_REG, &val2_mw);
+			if (ret)
+				return ret;
+			break;
+		default:
+			return -EOPNOTSUPP;
+		}
+
+		if (val_mw == 0xffff)
+			val_mw = 0;
+		if (val2_mw == 0xffff)
+			val2_mw = 0;
+
+		*val_pwr = (val + val2)*1000000 + (val_mw + val2_mw)*1000;
+		return 0;
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+static int smpro_read(struct device *dev, enum hwmon_sensor_types type,
+				u32 attr, int channel, long *val)
+{
+	switch (type) {
+	case hwmon_temp:
+		return smpro_read_temp(dev, attr, channel, val);
+	case hwmon_in:
+		return smpro_read_in(dev, attr, channel, val);
+	case hwmon_power:
+		return smpro_read_power(dev, attr, channel, val);
+	case hwmon_curr:
+		return smpro_read_curr(dev, attr, channel, val);
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+static int smpro_write(struct device *dev, enum hwmon_sensor_types type,
+				u32 attr, int channel, long val)
+{
+	return -EOPNOTSUPP;
+}
+
+static umode_t smpro_is_visible(const void *data,
+				enum hwmon_sensor_types type,
+				u32 attr, int channel)
+{
+	return 0444;
+}
+
+static ssize_t show_label(struct device *dev, struct device_attribute *devattr,
+				char *buf)
+{
+	int index = to_sensor_dev_attr(devattr)->index;
+
+	return sprintf(buf, "%s\n", label[index]);
+}
+
+static const u32 smpro_temp_config[] = {
+	HWMON_T_INPUT,
+	HWMON_T_INPUT,
+	HWMON_T_INPUT,
+	HWMON_T_INPUT,
+	HWMON_T_INPUT,
+	HWMON_T_INPUT,
+	HWMON_T_INPUT,
+	HWMON_T_INPUT,
+	HWMON_T_INPUT,
+	HWMON_T_INPUT,
+	HWMON_T_INPUT,
+	HWMON_T_INPUT,
+	HWMON_T_INPUT,
+	HWMON_T_INPUT,
+	HWMON_T_INPUT,
+	HWMON_T_INPUT,
+	HWMON_T_INPUT,
+	0
+};
+
+static const struct hwmon_channel_info smpro_temp = {
+	.type = hwmon_temp,
+	.config = smpro_temp_config,
+};
+
+static const u32 smpro_in_config[] = {
+	HWMON_I_INPUT,
+	HWMON_I_INPUT,
+	HWMON_I_INPUT,
+	HWMON_I_INPUT,
+	HWMON_I_INPUT,
+	HWMON_I_INPUT,
+	0
+};
+
+static const struct hwmon_channel_info smpro_in = {
+	.type = hwmon_in,
+	.config = smpro_in_config,
+};
+
+static const u32 smpro_curr_config[] = {
+	HWMON_C_INPUT,
+	HWMON_C_INPUT,
+	HWMON_C_INPUT,
+	HWMON_C_INPUT,
+	HWMON_C_INPUT,
+	0
+};
+
+static const struct hwmon_channel_info smpro_curr = {
+	.type = hwmon_curr,
+	.config = smpro_curr_config,
+};
+
+static const u32 smpro_power_config[] = {
+	HWMON_P_INPUT,
+	HWMON_P_INPUT,
+	HWMON_P_INPUT,
+	HWMON_P_INPUT,
+	HWMON_P_INPUT,
+	HWMON_P_INPUT,
+	HWMON_P_INPUT,
+	HWMON_P_INPUT,
+	0
+};
+
+static const struct hwmon_channel_info smpro_power = {
+	.type = hwmon_power,
+	.config = smpro_power_config,
+};
+
+static const struct hwmon_channel_info *smpro_info[] = {
+	&smpro_temp,
+	&smpro_in,
+	&smpro_power,
+	&smpro_curr,
+	NULL
+};
+
+static const struct hwmon_ops smpro_hwmon_ops = {
+	.is_visible = smpro_is_visible,
+	.read = smpro_read,
+	.write = smpro_write,
+};
+
+static const struct hwmon_chip_info smpro_chip_info = {
+	.ops = &smpro_hwmon_ops,
+	.info = smpro_info,
+};
+
+static SENSOR_DEVICE_ATTR(temp1_label, 0444, show_label, NULL, 0);
+static SENSOR_DEVICE_ATTR(temp2_label, 0444, show_label, NULL, 1);
+static SENSOR_DEVICE_ATTR(temp3_label, 0444, show_label, NULL, 2);
+static SENSOR_DEVICE_ATTR(temp4_label, 0444, show_label, NULL, 5);
+static SENSOR_DEVICE_ATTR(temp5_label, 0444, show_label, NULL, 19);
+static SENSOR_DEVICE_ATTR(temp6_label, 0444, show_label, NULL, 6);
+static SENSOR_DEVICE_ATTR(temp7_label, 0444, show_label, NULL, 7);
+static SENSOR_DEVICE_ATTR(temp8_label, 0444, show_label, NULL, 8);
+static SENSOR_DEVICE_ATTR(temp9_label, 0444, show_label, NULL, 9);
+static SENSOR_DEVICE_ATTR(temp10_label, 0444, show_label, NULL, 20);
+static SENSOR_DEVICE_ATTR(temp11_label, 0444, show_label, NULL, 10);
+static SENSOR_DEVICE_ATTR(temp12_label, 0444, show_label, NULL, 11);
+static SENSOR_DEVICE_ATTR(temp13_label, 0444, show_label, NULL, 12);
+static SENSOR_DEVICE_ATTR(temp14_label, 0444, show_label, NULL, 13);
+static SENSOR_DEVICE_ATTR(temp15_label, 0444, show_label, NULL, 14);
+static SENSOR_DEVICE_ATTR(temp16_label, 0444, show_label, NULL, 15);
+static SENSOR_DEVICE_ATTR(temp17_label, 0444, show_label, NULL, 17);
+
+static SENSOR_DEVICE_ATTR(in0_label, 0444, show_label, NULL, 5);
+static SENSOR_DEVICE_ATTR(in1_label, 0444, show_label, NULL, 1);
+static SENSOR_DEVICE_ATTR(in2_label, 0444, show_label, NULL, 3);
+static SENSOR_DEVICE_ATTR(in3_label, 0444, show_label, NULL, 4);
+static SENSOR_DEVICE_ATTR(in4_label, 0444, show_label, NULL, 2);
+static SENSOR_DEVICE_ATTR(in5_label, 0444, show_label, NULL, 17);
+
+static SENSOR_DEVICE_ATTR(power1_label, 0444, show_label, NULL, 5);
+static SENSOR_DEVICE_ATTR(power2_label, 0444, show_label, NULL, 1);
+static SENSOR_DEVICE_ATTR(power3_label, 0444, show_label, NULL, 3);
+static SENSOR_DEVICE_ATTR(power4_label, 0444, show_label, NULL, 4);
+static SENSOR_DEVICE_ATTR(power5_label, 0444, show_label, NULL, 16);
+static SENSOR_DEVICE_ATTR(power6_label, 0444, show_label, NULL, 2);
+static SENSOR_DEVICE_ATTR(power7_label, 0444, show_label, NULL, 17);
+static SENSOR_DEVICE_ATTR(power8_label, 0444, show_label, NULL, 18);
+
+static SENSOR_DEVICE_ATTR(curr1_label, 0444, show_label, NULL, 5);
+static SENSOR_DEVICE_ATTR(curr2_label, 0444, show_label, NULL, 1);
+static SENSOR_DEVICE_ATTR(curr3_label, 0444, show_label, NULL, 3);
+static SENSOR_DEVICE_ATTR(curr4_label, 0444, show_label, NULL, 4);
+static SENSOR_DEVICE_ATTR(curr5_label, 0444, show_label, NULL, 17);
+
+static struct attribute *smpro_attrs[] = {
+	&sensor_dev_attr_temp1_label.dev_attr.attr,
+	&sensor_dev_attr_temp2_label.dev_attr.attr,
+	&sensor_dev_attr_temp3_label.dev_attr.attr,
+	&sensor_dev_attr_temp4_label.dev_attr.attr,
+	&sensor_dev_attr_temp5_label.dev_attr.attr,
+	&sensor_dev_attr_temp6_label.dev_attr.attr,
+	&sensor_dev_attr_temp7_label.dev_attr.attr,
+	&sensor_dev_attr_temp8_label.dev_attr.attr,
+	&sensor_dev_attr_temp9_label.dev_attr.attr,
+	&sensor_dev_attr_temp10_label.dev_attr.attr,
+	&sensor_dev_attr_temp11_label.dev_attr.attr,
+	&sensor_dev_attr_temp12_label.dev_attr.attr,
+	&sensor_dev_attr_temp13_label.dev_attr.attr,
+	&sensor_dev_attr_temp14_label.dev_attr.attr,
+	&sensor_dev_attr_temp15_label.dev_attr.attr,
+	&sensor_dev_attr_temp16_label.dev_attr.attr,
+	&sensor_dev_attr_temp17_label.dev_attr.attr,
+
+	&sensor_dev_attr_in0_label.dev_attr.attr,
+	&sensor_dev_attr_in1_label.dev_attr.attr,
+	&sensor_dev_attr_in2_label.dev_attr.attr,
+	&sensor_dev_attr_in3_label.dev_attr.attr,
+	&sensor_dev_attr_in4_label.dev_attr.attr,
+	&sensor_dev_attr_in5_label.dev_attr.attr,
+
+	&sensor_dev_attr_curr1_label.dev_attr.attr,
+	&sensor_dev_attr_curr2_label.dev_attr.attr,
+	&sensor_dev_attr_curr3_label.dev_attr.attr,
+	&sensor_dev_attr_curr4_label.dev_attr.attr,
+	&sensor_dev_attr_curr5_label.dev_attr.attr,
+
+	&sensor_dev_attr_power1_label.dev_attr.attr,
+	&sensor_dev_attr_power2_label.dev_attr.attr,
+	&sensor_dev_attr_power3_label.dev_attr.attr,
+	&sensor_dev_attr_power4_label.dev_attr.attr,
+	&sensor_dev_attr_power5_label.dev_attr.attr,
+	&sensor_dev_attr_power6_label.dev_attr.attr,
+	&sensor_dev_attr_power7_label.dev_attr.attr,
+	&sensor_dev_attr_power8_label.dev_attr.attr,
+
+	NULL
+};
+ATTRIBUTE_GROUPS(smpro);
+
+static int check_valid_id (struct regmap *regmap)
+{
+	unsigned int val;
+	int ret;
+
+	ret = regmap_read(regmap, MANUFACTURER_ID_REG, &val);
+	if (ret)
+		return ret;
+
+	return  (val == AMPERE_MANUFACTURER_ID) ? 0 : 1;
+}
+
+static int smpro_hwmon_probe(struct platform_device *pdev)
+{
+	struct smpro_hwmon *hwmon;
+	struct device *hwmon_dev;
+	int ret;
+
+	hwmon = devm_kzalloc(&pdev->dev, sizeof(struct smpro_hwmon),
+			GFP_KERNEL);
+	if (!hwmon)
+		return -ENOMEM;
+
+	hwmon->regmap = dev_get_regmap(pdev->dev.parent, NULL);
+	if (!hwmon->regmap)
+		return -ENODEV;
+
+	/* Check for valid ID */
+	ret = check_valid_id(hwmon->regmap);
+	if (ret)
+		dev_warn(&pdev->dev, "Hmmh, SMPro not ready yet\n");
+
+	hwmon_dev = devm_hwmon_device_register_with_info(&pdev->dev,
+			"smpro_hwmon", hwmon,
+			&smpro_chip_info, smpro_groups);
+	if (IS_ERR(hwmon_dev))
+		dev_err(&pdev->dev, "failed to register as hwmon device");
+
+	return PTR_ERR_OR_ZERO(hwmon_dev);
+}
+
+static const struct of_device_id smpro_hwmon_of_match[] = {
+	{ .compatible = "ampere,ac01-hwmon" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, smpro_hwmon_of_match);
+
+static struct platform_driver smpro_hwmon_driver = {
+	.probe		= smpro_hwmon_probe,
+	.driver = {
+		.name	= "smpro-hwmon",
+		.of_match_table = smpro_hwmon_of_match,
+	},
+};
+
+module_platform_driver(smpro_hwmon_driver);
+
+MODULE_AUTHOR("Thinh Pham <thinh.pham@amperecomputing.com>");
+MODULE_AUTHOR("Hoang Nguyen <hnguyen@amperecomputing.com>");
+MODULE_AUTHOR("Thu Nguyen <tbnguyen@amperecomputing.com>");
+MODULE_DESCRIPTION("Ampere Altra SMpro hwmon driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index a311541bce2c..c738a8e5ae81 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -1179,6 +1179,38 @@ config MFD_SI476X_CORE
 	  To compile this driver as a module, choose M here: the
 	  module will be called si476x-core.
 
+config MFD_SIMPLE_MFD_I2C
+	tristate
+	depends on I2C
+	select REGMAP_I2C
+	help
+	  This driver creates a single register map with the intention for it
+	  to be shared by all sub-devices.
+
+	  Once the register map has been successfully initialised, any
+	  sub-devices represented by child nodes in Device Tree will be
+	  subsequently registered.
+
+config MFD_SL28CPLD
+	tristate "Kontron sl28cpld Board Management Controller"
+	select MFD_SIMPLE_MFD_I2C
+	help
+	  Say yes here to enable support for the Kontron sl28cpld board
+	  management controller.
+
+	  It can be found on the following boards:
+		* SMARC-sAL28
+
+config MFD_SMPRO
+	tristate "Ampere Computing MFD SMPRO core driver"
+	select MFD_SIMPLE_MFD_I2C
+	help
+	  Say yes here to enable support for Ampere Computing SMPro driver
+	  management controller.
+
+	  Ampere Computing SMPro expose a i2c regmap interface so that it can
+	  be accessed by children devices.
+
 config MFD_SM501
 	tristate "Silicon Motion SM501"
 	depends on HAS_DMA
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index e288e586b687..8ef6f6f245c9 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -263,5 +263,5 @@ obj-$(CONFIG_MFD_ROHM_BD70528)	+= rohm-bd70528.o
 obj-$(CONFIG_MFD_ROHM_BD71828)	+= rohm-bd71828.o
 obj-$(CONFIG_MFD_ROHM_BD718XX)	+= rohm-bd718x7.o
 obj-$(CONFIG_MFD_STMFX) 	+= stmfx.o
-
+obj-$(CONFIG_MFD_SIMPLE_MFD_I2C)	+= simple-mfd-i2c.o
 obj-$(CONFIG_SGI_MFD_IOC3)	+= ioc3.o
diff --git a/drivers/mfd/simple-mfd-i2c.c b/drivers/mfd/simple-mfd-i2c.c
new file mode 100644
index 000000000000..0459a9fbd3f5
--- /dev/null
+++ b/drivers/mfd/simple-mfd-i2c.c
@@ -0,0 +1,68 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Simple MFD - I2C
+ *
+ * This driver creates a single register map with the intention for it to be
+ * shared by all sub-devices.  Children can use their parent's device structure
+ * (dev.parent) in order to reference it.
+ *
+ * Once the register map has been successfully initialised, any sub-devices
+ * represented by child nodes in Device Tree will be subsequently registered.
+ */
+
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/regmap.h>
+
+static const struct regmap_config simple_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+};
+
+static const struct regmap_config simple_word_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 16,
+};
+
+static int simple_mfd_i2c_probe(struct i2c_client *i2c)
+{
+	const struct regmap_config *config;
+	struct regmap *regmap;
+
+	config = device_get_match_data(&i2c->dev);
+	if (!config) {
+		if (of_device_is_compatible(i2c->dev.of_node,
+						"ampere,ac01-smpro"))
+			config = &simple_word_regmap_config;
+		else
+			config = &simple_regmap_config;
+	}
+
+	regmap = devm_regmap_init_i2c(i2c, config);
+	if (IS_ERR(regmap))
+		return PTR_ERR(regmap);
+
+	return devm_of_platform_populate(&i2c->dev);
+}
+
+static const struct of_device_id simple_mfd_i2c_of_match[] = {
+	{ .compatible = "kontron,sl28cpld" },
+	{ .compatible = "ampere,ac01-smpro" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, simple_mfd_i2c_of_match);
+
+static struct i2c_driver simple_mfd_i2c_driver = {
+	.probe_new = simple_mfd_i2c_probe,
+	.driver = {
+		.name = "simple-mfd-i2c",
+		.of_match_table = simple_mfd_i2c_of_match,
+	},
+};
+module_i2c_driver(simple_mfd_i2c_driver);
+
+MODULE_AUTHOR("Michael Walle <michael@walle.cc>");
+MODULE_DESCRIPTION("Simple MFD - I2C driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index d8626a0d3e31..c638ab8652dd 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -197,6 +197,20 @@ config SGI_XP
 	  this feature will allow for direct communication between SSIs
 	  based on a network adapter and DMA messaging.
 
+config SMPRO_ERRMON
+	tristate "Ampere Computing SMPro error monitor driver"
+	depends on MFD_SMPRO || COMPILE_TEST
+	help
+	  If you say yes here you get support for error monitor function
+	  provides by Ampere Computing's SoC with SMpro processor.
+
+config SMPRO_MISC
+	tristate "Ampere Computing SMPro miscellaneous driver"
+	depends on MFD_SMPRO || COMPILE_TEST
+	help
+	  If you say yes here you get support for the miscellaleous function
+	  provides by Ampere Computing's SoC with SMpro processor.
+
 config CS5535_MFGPT
 	tristate "CS5535/CS5536 Geode Multi-Function General Purpose Timer (MFGPT) support"
 	depends on MFD_CS5535
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 183970192ced..f99291603dc8 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -25,6 +25,8 @@ obj-$(CONFIG_ENCLOSURE_SERVICES) += enclosure.o
 obj-$(CONFIG_KGDB_TESTS)	+= kgdbts.o
 obj-$(CONFIG_SGI_XP)		+= sgi-xp/
 obj-$(CONFIG_SGI_GRU)		+= sgi-gru/
+obj-$(CONFIG_SMPRO_ERRMON)	+= smpro-errmon.o
+obj-$(CONFIG_SMPRO_MISC)	+= smpro-misc.o
 obj-$(CONFIG_CS5535_MFGPT)	+= cs5535-mfgpt.o
 obj-$(CONFIG_HP_ILO)		+= hpilo.o
 obj-$(CONFIG_APDS9802ALS)	+= apds9802als.o
diff --git a/drivers/misc/smpro-errmon.c b/drivers/misc/smpro-errmon.c
new file mode 100644
index 000000000000..51b7aa65838e
--- /dev/null
+++ b/drivers/misc/smpro-errmon.c
@@ -0,0 +1,587 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Ampere Computing SoC's SMpro Error Monitoring Driver
+ *
+ * Copyright (c) 2019-2020, Ampere Computing LLC
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/i2c.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+
+/* Identification Registers */
+#define MANUFACTURER_ID_REG	0x02
+#define AMPERE_MANUFACTURER_ID	0xCD3A
+
+/* GPI RAS Error Registers */
+#define GPI_RAS_ERR_REG		0x7E
+
+/* Core and L2C Error Registers */
+#define CORE_CE_ERR_CNT_REG	0x80
+#define CORE_CE_ERR_LEN_REG	0x81
+#define CORE_CE_ERR_DATA_REG	0x82
+#define CORE_UE_ERR_CNT_REG	0x83
+#define CORE_UE_ERR_LEN_REG	0x84
+#define CORE_UE_ERR_DATA_REG	0x85
+
+/* Memory Error Registers */
+#define MEM_CE_ERR_CNT_REG	0x90
+#define MEM_CE_ERR_LEN_REG	0x91
+#define MEM_CE_ERR_DATA_REG	0x92
+#define MEM_UE_ERR_CNT_REG	0x93
+#define MEM_UE_ERR_LEN_REG	0x94
+#define MEM_UE_ERR_DATA_REG	0x95
+
+/* RAS Error/Warning Registers */
+#define ERR_SMPRO_TYPE_REG	0xA0
+#define ERR_PMPRO_TYPE_REG	0xA1
+#define ERR_SMPRO_INFO_LO_REG	0xA2
+#define ERR_SMPRO_INFO_HI_REG	0xA3
+#define ERR_SMPRO_DATA_LO_REG	0xA4
+#define ERR_SMPRO_DATA_HI_REG	0xA5
+#define WARN_SMPRO_INFO_LO_REG	0xAA
+#define WARN_SMPRO_INFO_HI_REG	0xAB
+#define ERR_PMPRO_INFO_LO_REG	0xA6
+#define ERR_PMPRO_INFO_HI_REG	0xA7
+#define ERR_PMPRO_DATA_LO_REG	0xA8
+#define ERR_PMPRO_DATA_HI_REG	0xA9
+#define WARN_PMPRO_INFO_LO_REG	0xAC
+#define WARN_PMPRO_INFO_HI_REG	0xAD
+
+/* PCIE Error Registers */
+#define PCIE_CE_ERR_CNT_REG	0xC0
+#define PCIE_CE_ERR_LEN_REG	0xC1
+#define PCIE_CE_ERR_DATA_REG	0xC2
+#define PCIE_UE_ERR_CNT_REG	0xC3
+#define PCIE_UE_ERR_LEN_REG	0xC4
+#define PCIE_UE_ERR_DATA_REG	0xC5
+
+/* Other Error Registers */
+#define OTHER_CE_ERR_CNT_REG	0xD0
+#define OTHER_CE_ERR_LEN_REG	0xD1
+#define OTHER_CE_ERR_DATA_REG	0xD2
+#define OTHER_UE_ERR_CNT_REG	0xD8
+#define OTHER_UE_ERR_LEN_REG	0xD9
+#define OTHER_UE_ERR_DATA_REG	0xDA
+
+/* I2C read block data constant */
+#define MAX_READ_BLOCK_LENGTH	48
+#define NUM_I2C_MESSAGES	2
+#define MAX_READ_ERROR		35
+#define MAX_MSG_LEN		128
+
+#define RAS_SMPRO_ERRS		0
+#define RAS_PMPRO_ERRS		1
+
+/* Bit masks */
+#define BIT_0			0x0001
+#define BIT_1			0x0002
+#define BIT_2			0x0004
+#define BIT_8			0x0100
+
+enum RAS_48BYTES_ERR_TYPES {
+	CORE_CE_ERRS,
+	CORE_UE_ERRS,
+	MEM_CE_ERRS,
+	MEM_UE_ERRS,
+	PCIE_CE_ERRS,
+	PCIE_UE_ERRS,
+	OTHER_CE_ERRS,
+	OTHER_UE_ERRS,
+	NUM_48BYTES_ERR_TYPE,
+};
+
+/*
+ * The output of Core/Memory/PCIe/Others UE/CE errors follows below format:
+ * <Error Type>  <Error SubType>  <Instance>  <Error Status> \
+ * <Error Address>  <Error Misc 0> <Error Misc 1> <Error Misc2> <Error Misc 3>
+ * Where:
+ *  + Error Type: The hardwares cause the errors. (1 byte)
+ *  + SubType: Sub type of error in the specified hardware error. (1 byte)
+ *  + Instance: Combination of the socket, channel,
+ *    slot cause the error. (2 bytes)
+ *  + Error Status: Encode of error status. (4 bytes)
+ *  + Error Address: The address in device causes the errors. (8 bytes)
+ *  + Error Misc 0/1/2/3: Addition info about the errors. (8 bytes for each)
+ * Reference Altra SOC BMC Interface specification.
+ */
+u_int8_t field_size[9] = {1, 1, 2, 4, 8, 8, 8, 8, 8};
+
+struct smpro_error_hdr {
+	u8 err_count;	/* Number of the RAS errors */
+	u8 err_len;	/* Number of data bytes */
+	u8 err_data;	/* Start of 48-byte data */
+};
+/*
+ * Included Address of registers to get Count, Length of data and Data
+ * of the 48 bytes error data
+ */
+struct smpro_error_hdr smpro_error_table[NUM_48BYTES_ERR_TYPE] = {
+	{CORE_CE_ERR_CNT_REG, CORE_CE_ERR_LEN_REG, CORE_CE_ERR_DATA_REG},
+	{CORE_UE_ERR_CNT_REG, CORE_UE_ERR_LEN_REG, CORE_UE_ERR_DATA_REG},
+	{MEM_CE_ERR_CNT_REG, MEM_CE_ERR_LEN_REG, MEM_CE_ERR_DATA_REG},
+	{MEM_UE_ERR_CNT_REG, MEM_UE_ERR_LEN_REG, MEM_UE_ERR_DATA_REG},
+	{PCIE_CE_ERR_CNT_REG, PCIE_CE_ERR_LEN_REG, PCIE_CE_ERR_DATA_REG},
+	{PCIE_UE_ERR_CNT_REG, PCIE_UE_ERR_LEN_REG, PCIE_UE_ERR_DATA_REG},
+	{OTHER_CE_ERR_CNT_REG, OTHER_CE_ERR_LEN_REG, OTHER_CE_ERR_DATA_REG},
+	{OTHER_UE_ERR_CNT_REG, OTHER_UE_ERR_LEN_REG, OTHER_UE_ERR_DATA_REG},
+};
+
+/*
+ * List of SCP registers which are used to get
+ * one type of RAS Internal errors.
+ */
+struct smpro_int_error_hdr {
+	u8 err_type;
+	u8 err_info_low;
+	u8 err_info_high;
+	u8 err_data_high;
+	u8 err_data_low;
+	u8 warn_info_low;
+	u8 warn_info_high;
+};
+
+struct smpro_int_error_hdr list_smpro_int_error_hdr[2] = {
+	{
+	 ERR_SMPRO_TYPE_REG,
+	 ERR_SMPRO_INFO_LO_REG, ERR_SMPRO_INFO_HI_REG,
+	 ERR_SMPRO_DATA_LO_REG, ERR_SMPRO_DATA_HI_REG,
+	 WARN_SMPRO_INFO_LO_REG, WARN_SMPRO_INFO_HI_REG
+	},
+	{
+	 ERR_PMPRO_TYPE_REG,
+	 ERR_PMPRO_INFO_LO_REG, ERR_PMPRO_INFO_HI_REG,
+	 ERR_PMPRO_DATA_LO_REG, ERR_PMPRO_DATA_HI_REG,
+	 WARN_PMPRO_INFO_LO_REG, WARN_PMPRO_INFO_HI_REG
+	},
+};
+
+struct smpro_errmon {
+	struct regmap *regmap;
+};
+
+static int read_i2c_block_data(struct i2c_client *client,
+				u16 address, u16 length, u8 *data)
+{
+	struct i2c_msg msgs[2];
+	unsigned char msgbuf0[2];
+	unsigned char msgbuf1[MAX_READ_BLOCK_LENGTH + 2];
+	ssize_t ret;
+	u8 i = 0;
+
+	if (length > MAX_READ_BLOCK_LENGTH)
+		return -EINVAL;
+
+	msgbuf0[0] = (address & 0xff);
+	msgbuf0[1] = length;
+
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags & I2C_M_TEN;
+	msgs[0].len = 2;
+	msgs[0].buf = msgbuf0;
+
+	msgs[1].addr = client->addr;
+	msgs[1].flags = (client->flags  & I2C_M_TEN) | I2C_M_RD;
+	msgs[1].len = length;
+	msgs[1].buf = msgbuf1;
+
+	ret = i2c_transfer(client->adapter, msgs, NUM_I2C_MESSAGES);
+	if (ret < 0)
+		return ret;
+
+	if (ret != NUM_I2C_MESSAGES)
+		return -EIO;
+
+	for (i = 0; i < length; i++)
+		data[i] = msgbuf1[i];
+
+	return length;
+}
+
+static int errmon_read_block(struct regmap *map, u16 address, u16 length, u8 *data)
+{
+	struct i2c_client *client = to_i2c_client(regmap_get_device(map));
+	int ret;
+
+	regmap_acquire_lock(map);
+
+	ret = read_i2c_block_data(client, address, length, data);
+
+	regmap_release_lock(map);
+
+	return ret;
+}
+
+static int format_error_output(unsigned char datas[], size_t data_len,
+			       char *buf, size_t buf_len)
+{
+	unsigned char str[3] = {'\0'};
+	u8 x = 0, y = 0, curPos = 0;
+
+	if (data_len < MAX_READ_BLOCK_LENGTH + 2)
+		return 0;
+	if (buf_len < MAX_MSG_LEN)
+		return 0;
+
+	for (x = 0; x < sizeof(field_size); x++) {
+		for (y = 0; y < field_size[x]; y++) {
+			snprintf(str, 3, "%02x",
+				datas[curPos + field_size[x] - y - 1]);
+			strncat(buf, str, strlen(str));
+		}
+		strncat(buf, " ", strlen(" "));
+		curPos = curPos + field_size[x];
+	}
+	return 1;
+}
+
+static ssize_t smpro_error_data_read(struct device *dev,
+				 struct device_attribute *da, char *buf, int channel)
+{
+	struct smpro_errmon *errmon = dev_get_drvdata(dev);
+	unsigned char err_data[MAX_READ_BLOCK_LENGTH + 2];
+	unsigned char msg[MAX_MSG_LEN] = {'\0'};
+	struct smpro_error_hdr err_info;
+	s32 err_count = 1, err_length = 0;
+	u8 i = 0;
+	int ret;
+
+	*buf = 0;
+	if (channel >= NUM_48BYTES_ERR_TYPE)
+		goto done;
+
+	err_info = smpro_error_table[channel];
+
+	memset(err_data, 0xff, MAX_READ_BLOCK_LENGTH + 2);
+
+	ret = regmap_read(errmon->regmap, err_info.err_count, &err_count);
+	if (ret || err_count <= 0)
+		goto done;
+
+	if (err_count > MAX_READ_ERROR)
+		err_count = MAX_READ_ERROR;
+
+	for (i = 0; i < err_count; i++) {
+		ret = regmap_read(errmon->regmap, err_info.err_len, &err_length);
+		if (ret || err_length <= 0)
+			break;
+
+		if (err_length > MAX_READ_BLOCK_LENGTH)
+			err_length = MAX_READ_BLOCK_LENGTH;
+
+		ret = errmon_read_block(errmon->regmap, err_info.err_data,
+			err_length, err_data);
+		if (ret < 0)
+			break;
+
+		snprintf(msg, MAX_MSG_LEN, "%s", "");
+		format_error_output(err_data, MAX_READ_BLOCK_LENGTH + 2,
+			msg, MAX_MSG_LEN);
+		strcat(msg, "\n");
+
+		/* go to next error */
+		ret = regmap_write(errmon->regmap, err_info.err_count, 0x100);
+		if (ret)
+			break;
+
+		/* add error message to buffer */
+		strncat(buf, msg, strlen(msg));
+	}
+done:
+	return strlen(buf);
+}
+
+static s32 smpro_internal_err_get_info(struct regmap *regmap, u8 addr,
+	u8 addr1, u8 addr2, u8 addr3, u8 subtype, char *buf)
+{
+	unsigned int retHi = 0, retLo = 0, dataLo = 0, dataHi = 0;
+	int ret;
+
+	snprintf(buf, MAX_MSG_LEN, "%s", "");
+
+	ret = regmap_read(regmap, addr, &retLo);
+	if (ret)
+		return ret;
+
+	ret = regmap_read(regmap, addr1, &retHi);
+	if (ret)
+		return ret;
+
+	if (addr2 != 0xff) {
+		ret = regmap_read(regmap, addr2, &dataLo);
+		if (ret)
+			return ret;
+		ret = regmap_read(regmap, addr3, &dataHi);
+		if (ret)
+			return ret;
+	}
+	/*
+	 * Output format:
+	 * <errType> <image> <dir> <Location> <errorCode> <data>
+	 * Where:
+	 *   + errType: SCP Error Type (3 bits)
+	 *      1: Warning
+	 *      2: Error
+	 *      4: Error with data
+	 *   + image: SCP Image Code (8 bits)
+	 *   + dir: Direction (1 bit)
+	 *      0: Enter
+	 *      1: Exit
+	 *   + location: SCP Module Location Code (8 bits)
+	 *   + errorCode: SCP Error Code (16 bits)
+	 *   + data : Extensive data (32 bits)
+	 *      All bits are 0 when errType is warning or error.
+	 */
+	scnprintf(buf, MAX_MSG_LEN, "%01x %02x %01x %02x %04x %04x%04x\n",
+			subtype, (retHi & 0xf000) >> 12,
+			(retHi & 0x0800) >> 11, retHi & 0xff, retLo,
+			dataHi, dataLo);
+
+	return strlen(buf);
+}
+
+static ssize_t smpro_internal_err_read(struct device *dev,
+				struct device_attribute *da, char *buf, int channel)
+{
+	struct smpro_errmon *errmon = dev_get_drvdata(dev);
+	struct smpro_int_error_hdr err_info;
+	unsigned char msg[MAX_MSG_LEN] = {'\0'};
+	unsigned int err_type;
+	unsigned int value;
+	int ret = 0;
+
+	*buf = 0;
+
+	if (!(channel == RAS_SMPRO_ERRS || channel == RAS_PMPRO_ERRS))
+		goto done;
+
+	/* read error status */
+	ret = regmap_read(errmon->regmap, GPI_RAS_ERR_REG, &value);
+	if (ret)
+		goto done;
+
+	if (!((channel == RAS_SMPRO_ERRS && (value & BIT_0)) ||
+		(channel == RAS_PMPRO_ERRS && (value & BIT_1))))
+		goto done;
+
+	err_info = list_smpro_int_error_hdr[channel];
+	ret = regmap_read(errmon->regmap, err_info.err_type, &err_type);
+	if (ret)
+		goto done;
+
+	/* Warning type */
+	if (err_type & BIT_0) {
+		ret = smpro_internal_err_get_info(errmon->regmap,
+						err_info.warn_info_low,
+						err_info.warn_info_high,
+						0xff, 0xff, 1, msg);
+		if (ret < 0)
+			goto done;
+
+		strncat(buf, msg, strlen(msg));
+	}
+
+	/* Error with data type */
+	if (err_type & BIT_2) {
+		ret = smpro_internal_err_get_info(errmon->regmap,
+					      err_info.err_info_low,
+					      err_info.err_info_high,
+					      err_info.err_data_low,
+					      err_info.err_data_high, 4, msg);
+		if (ret < 0)
+			goto done;
+
+		strncat(buf, msg, strlen(msg));
+	}
+	/* Error type */
+	else if (err_type & BIT_1) {
+		ret = smpro_internal_err_get_info(errmon->regmap,
+						err_info.err_info_low,
+						err_info.err_info_high,
+						0xff, 0xff, 2, msg);
+		if (ret < 0)
+			goto done;
+
+		strncat(buf, msg, strlen(msg));
+	}
+
+	/* clear the read errors */
+	regmap_write(errmon->regmap, err_info.err_type, err_type);
+
+done:
+	return strlen(buf);
+}
+
+static int errors_core_ce_show(struct device *dev,
+		struct device_attribute *da, char *buf)
+{
+	return smpro_error_data_read(dev, da, buf, CORE_CE_ERRS);
+}
+static DEVICE_ATTR_RO(errors_core_ce);
+
+static int errors_core_ue_show(struct device *dev,
+		struct device_attribute *da, char *buf)
+{
+	return smpro_error_data_read(dev, da, buf, CORE_UE_ERRS);
+}
+static DEVICE_ATTR_RO(errors_core_ue);
+
+static int errors_mem_ce_show(struct device *dev,
+		struct device_attribute *da, char *buf)
+{
+	return smpro_error_data_read(dev, da, buf, MEM_CE_ERRS);
+}
+static DEVICE_ATTR_RO(errors_mem_ce);
+
+static int errors_mem_ue_show(struct device *dev,
+		struct device_attribute *da, char *buf)
+{
+	return smpro_error_data_read(dev, da, buf, MEM_UE_ERRS);
+}
+static DEVICE_ATTR_RO(errors_mem_ue);
+
+static int errors_pcie_ce_show(struct device *dev,
+		struct device_attribute *da, char *buf)
+{
+	return smpro_error_data_read(dev, da, buf, PCIE_CE_ERRS);
+}
+static DEVICE_ATTR_RO(errors_pcie_ce);
+
+static int errors_pcie_ue_show(struct device *dev,
+		struct device_attribute *da, char *buf)
+{
+	return smpro_error_data_read(dev, da, buf, PCIE_UE_ERRS);
+}
+static DEVICE_ATTR_RO(errors_pcie_ue);
+
+static int errors_other_ce_show(struct device *dev,
+		struct device_attribute *da, char *buf)
+{
+	return smpro_error_data_read(dev, da, buf, OTHER_CE_ERRS);
+}
+static DEVICE_ATTR_RO(errors_other_ce);
+
+static int errors_other_ue_show(struct device *dev,
+		struct device_attribute *da, char *buf)
+{
+	return smpro_error_data_read(dev, da, buf, OTHER_UE_ERRS);
+}
+static DEVICE_ATTR_RO(errors_other_ue);
+
+static int errors_smpro_show(struct device *dev,
+		struct device_attribute *da, char *buf)
+{
+	return smpro_internal_err_read(dev, da, buf, RAS_SMPRO_ERRS);
+}
+static DEVICE_ATTR_RO(errors_smpro);
+
+static int errors_pmpro_show(struct device *dev,
+		struct device_attribute *da, char *buf)
+{
+	return smpro_internal_err_read(dev, da, buf, RAS_PMPRO_ERRS);
+}
+static DEVICE_ATTR_RO(errors_pmpro);
+
+static struct attribute *smpro_errmon_attrs[] = {
+	&dev_attr_errors_core_ce.attr,
+	&dev_attr_errors_core_ue.attr,
+	&dev_attr_errors_mem_ce.attr,
+	&dev_attr_errors_mem_ue.attr,
+	&dev_attr_errors_pcie_ce.attr,
+	&dev_attr_errors_pcie_ue.attr,
+	&dev_attr_errors_other_ce.attr,
+	&dev_attr_errors_other_ue.attr,
+	&dev_attr_errors_smpro.attr,
+	&dev_attr_errors_pmpro.attr,
+	NULL
+};
+
+static const struct attribute_group smpro_errmon_attr_group = {
+	.attrs = smpro_errmon_attrs
+};
+
+static int check_valid_id (struct regmap *regmap)
+{
+	unsigned int val;
+	int ret;
+
+	ret = regmap_read(regmap, MANUFACTURER_ID_REG, &val);
+	if (ret)
+		return ret;
+	return (val == AMPERE_MANUFACTURER_ID) ? 0 : 1;
+}
+
+static int smpro_errmon_probe(struct platform_device *pdev)
+{
+	struct smpro_errmon *errmon;
+	int ret;
+
+	errmon = devm_kzalloc(&pdev->dev, sizeof(struct smpro_errmon),
+			GFP_KERNEL);
+	if (!errmon)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, errmon);
+
+	errmon->regmap = dev_get_regmap(pdev->dev.parent, NULL);
+	if (!errmon->regmap)
+		return -ENODEV;
+
+	/* Check for valid ID */
+	ret = check_valid_id(errmon->regmap);
+	if (ret)
+		dev_warn(&pdev->dev, "Hmmh, SMPro not ready yet\n");
+
+	ret = sysfs_create_group(&pdev->dev.kobj, &smpro_errmon_attr_group);
+	if (ret)
+		dev_err(&pdev->dev, "SMPro errmon sysfs registration failed\n");
+
+	return 0;
+}
+
+static int smpro_errmon_remove(struct platform_device *pdev)
+{
+	sysfs_remove_group(&pdev->dev.kobj, &smpro_errmon_attr_group);
+	pr_info("SMPro errmon sysfs entries removed");
+
+	return 0;
+}
+
+static const struct of_device_id smpro_errmon_of_match[] = {
+	{ .compatible = "ampere,ac01-errmon" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, smpro_errmon_of_match);
+
+static struct platform_driver smpro_errmon_driver = {
+	.probe          = smpro_errmon_probe,
+	.remove         = smpro_errmon_remove,
+	.driver = {
+		.name   = "smpro-errmon",
+		.of_match_table = smpro_errmon_of_match,
+	},
+};
+
+module_platform_driver(smpro_errmon_driver);
+
+MODULE_AUTHOR("Tung Nguyen <tung.nguyen@amperecomputing.com>");
+MODULE_AUTHOR("Thinh Pham <thinh.pham@amperecomputing.com>");
+MODULE_AUTHOR("Hoang Nguyen <hnguyen@amperecomputing.com>");
+MODULE_AUTHOR("Thu Nguyen <tbnguyen@amperecomputing.com>");
+MODULE_DESCRIPTION("Ampere Altra SMpro driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/misc/smpro-misc.c b/drivers/misc/smpro-misc.c
new file mode 100644
index 000000000000..eb5af7012c21
--- /dev/null
+++ b/drivers/misc/smpro-misc.c
@@ -0,0 +1,249 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Ampere Computing SoC's SMpro Misc Driver
+ *
+ * Copyright (c) 2019-2020, Ampere Computing LLC
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+
+/* Identification Registers */
+#define MANUFACTURER_ID_REG	0x02
+#define AMPERE_MANUFACTURER_ID	0xCD3A
+
+/* Boot Stage/Progress Registers */
+#define BOOT_STAGE_SELECT_REG		0xB0
+#define BOOT_STAGE_STATUS_LO_REG	0xB1
+#define BOOT_STAGE_CUR_STAGE_REG	0xB2
+#define BOOT_STAGE_STATUS_HI_REG	0xB3
+
+/* ACPI State Registers */
+#define ACPI_POWER_LIMIT_REG	0xE5
+
+/* Boot stages */
+enum {
+	BOOT_STAGE_SMPRO = 0,
+	BOOT_STAGE_PMPRO,
+	BOOT_STAGE_ATF_BL1,
+	BOOT_STAGE_DDR_INIT,
+	BOOT_STAGE_DDR_INIT_PROGRESS,
+	BOOT_STAGE_ATF_BL2,
+	BOOT_STAGE_ATF_BL31,
+	BOOT_STAGE_ATF_BL32,
+	BOOT_STAGE_UEFI,
+	BOOT_STAGE_OS,
+	BOOT_STAGE_MAX
+};
+
+struct smpro_misc {
+	struct regmap *regmap;
+};
+
+static int boot_progress_show(struct device *dev,
+		struct device_attribute *da, char *buf)
+{
+	struct smpro_misc *misc = dev_get_drvdata(dev);
+	u32 boot_stage_high_reg;
+	u32 boot_stage_low_reg;
+	u32 current_boot_stage;
+	u32 boot_stage_reg;
+	u32 boot_progress;
+	u8 boot_status;
+	u8 boot_stage;
+	int stage_cnt;
+	int ret;
+
+
+	/* Read current boot stage */
+	ret = regmap_read(misc->regmap,
+			BOOT_STAGE_CUR_STAGE_REG, &current_boot_stage);
+	if (ret)
+		return ret;
+
+	current_boot_stage &= 0xff;
+	stage_cnt = 0;
+	do {
+		/* Read the boot progress */
+		ret = regmap_read(misc->regmap,
+				BOOT_STAGE_SELECT_REG, &boot_stage_reg);
+		if (ret)
+			return ret;
+
+		boot_stage = (boot_stage_reg & 0xff00) >> 8;
+		boot_status = boot_stage_reg & 0xff;
+
+		if (boot_stage == current_boot_stage)
+			break;
+
+		stage_cnt++;
+		ret = regmap_write(misc->regmap, BOOT_STAGE_SELECT_REG,
+				((boot_stage_reg & 0xff00) | 0x1));
+		if (ret)
+			return ret;
+	/* Never exceeded max number of stages */
+	} while (stage_cnt < BOOT_STAGE_MAX);
+
+	if (boot_stage != current_boot_stage)
+		goto error;
+
+	switch (boot_stage) {
+	case BOOT_STAGE_UEFI:
+	case BOOT_STAGE_OS:
+		/*
+		 * The progress is 32 bits:
+		 * B3.byte[0] B3.byte[1] B1.byte[0] B1.byte[1]
+		 */
+		ret = regmap_read(misc->regmap,	BOOT_STAGE_STATUS_LO_REG,
+				&boot_stage_low_reg);
+		if (!ret)
+			ret = regmap_read(misc->regmap,
+					BOOT_STAGE_STATUS_HI_REG,
+					&boot_stage_high_reg);
+		if (ret)
+			return ret;
+
+		boot_progress = swab16(boot_stage_low_reg) |
+			swab16(boot_stage_high_reg) << 16;
+		goto done;
+	default:
+		goto done;
+	}
+
+error:
+	boot_stage = 0xff;
+	boot_status = 0xff;
+	boot_progress = 0xffffffff;
+done:
+	return snprintf(buf, PAGE_SIZE, "0x%02x 0x%02x 0x%08X\n",
+			boot_stage, boot_status, boot_progress);
+}
+
+static DEVICE_ATTR_RO(boot_progress);
+
+static int acpi_power_limit_show(struct device *dev,
+				struct device_attribute *da, char *buf)
+{
+	struct smpro_misc *misc = dev_get_drvdata(dev);
+	int ret;
+	unsigned int value;
+
+	ret = regmap_read(misc->regmap, ACPI_POWER_LIMIT_REG, &value);
+	if (ret)
+		return ret;
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", value);
+}
+
+static int acpi_power_limit_store(struct device *dev,
+				struct device_attribute *da,
+				const char *buf, size_t count)
+{
+	struct smpro_misc *misc = dev_get_drvdata(dev);
+	unsigned long val;
+	s32 ret;
+
+	ret = kstrtoul(buf, 16, &val);
+
+	ret = regmap_write(misc->regmap, ACPI_POWER_LIMIT_REG,
+			(unsigned int)val);
+	if (ret)
+		return -EPROTO;
+
+	return count;
+}
+
+static DEVICE_ATTR_RW(acpi_power_limit);
+
+static struct attribute *smpro_misc_attrs[] = {
+	&dev_attr_boot_progress.attr,
+	&dev_attr_acpi_power_limit.attr,
+	NULL
+};
+
+static const struct attribute_group smpro_misc_attr_group = {
+	.attrs = smpro_misc_attrs
+};
+
+static int check_valid_id(struct regmap *regmap)
+{
+	unsigned int val;
+	int ret;
+
+	ret = regmap_read(regmap, MANUFACTURER_ID_REG, &val);
+	if (ret)
+		return ret;
+	return  (val == AMPERE_MANUFACTURER_ID) ? 0 : 1;
+}
+
+static int smpro_misc_probe(struct platform_device *pdev)
+{
+	struct smpro_misc *misc;
+	int ret;
+
+	misc = devm_kzalloc(&pdev->dev, sizeof(struct smpro_misc),
+			GFP_KERNEL);
+	if (!misc)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, misc);
+
+	misc->regmap = dev_get_regmap(pdev->dev.parent, NULL);
+	if (!misc->regmap)
+		return -ENODEV;
+
+	/* Check for valid ID */
+	ret = check_valid_id(misc->regmap);
+	if (ret)
+		dev_warn(&pdev->dev, "Hmmh, SMPro not ready yet\n");
+
+	ret = sysfs_create_group(&pdev->dev.kobj, &smpro_misc_attr_group);
+	if (ret)
+		dev_err(&pdev->dev, "SMPro misc sysfs registration failed\n");
+
+	return 0;
+}
+
+static int smpro_misc_remove(struct platform_device *pdev)
+{
+	sysfs_remove_group(&pdev->dev.kobj, &smpro_misc_attr_group);
+	pr_info("SMPro misc sysfs entries removed");
+
+	return 0;
+}
+
+static const struct of_device_id smpro_misc_of_match[] = {
+	{ .compatible = "ampere,ac01-misc" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, smpro_misc_of_match);
+
+static struct platform_driver smpro_misc_driver = {
+	.probe		= smpro_misc_probe,
+	.remove		= smpro_misc_remove,
+	.driver = {
+		.name	= "smpro-misc",
+		.of_match_table = smpro_misc_of_match,
+	},
+};
+
+module_platform_driver(smpro_misc_driver);
+
+MODULE_AUTHOR("Tung Nguyen <tung.nguyen@amperecomputing.com>");
+MODULE_AUTHOR("Quan Nguyen <quan@os.amperecomputing.com>");
+MODULE_DESCRIPTION("Ampere Altra SMpro Misc driver");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/regmap.h b/include/linux/regmap.h
index cb666b9c6b6a..f02747a0e814 100644
--- a/include/linux/regmap.h
+++ b/include/linux/regmap.h
@@ -1061,6 +1061,8 @@ int regmap_async_complete(struct regmap *map);
 bool regmap_can_raw_write(struct regmap *map);
 size_t regmap_get_raw_read_max(struct regmap *map);
 size_t regmap_get_raw_write_max(struct regmap *map);
+void regmap_acquire_lock(struct regmap *map);
+void regmap_release_lock(struct regmap *map);
 
 int regcache_sync(struct regmap *map);
 int regcache_sync_region(struct regmap *map, unsigned int min,
-- 
2.17.1

